@page "/"
@using Status = Shared.Status
@using RedBoxServices
@using Shared
@using Grpc.Core
@using Microsoft.AspNetCore.Components.Forms
@using Frontend.Models
@using Google.Protobuf
@using Google.Protobuf.WellKnownTypes
@using Frontend.Client_Utility
@using System.Text
@using System.Security.Cryptography
@inject ClientUtility ClientUtility
@inject GrpcAccountServices.GrpcAccountServicesClient UserService
@inject GrpcConversationServices.GrpcConversationServicesClient ConversationServices
@inject NavigationManager NavigationManager


<head>
    <title>Messages</title>
</head>

@if (_isLoaded)
{
    @if (_isError)
    {
        <div class="ui negative message">
            <i class="close icon"></i>
            <div class="header">
                @_errorTitle
            </div>
            <p>
                @_errorMessage
            </p>
        </div>
    }
    else if (_showNoUserFound)
    {
        <div class="ui info message">
            <i class="close icon"></i>
            <div class="header">
                Non ci sono utenti con cui iniziare una conversazione
            </div>
            Aspetta che nuovi utenti vengano aggiunti all'applicazione
        </div>
    }

    <div class="ui top attached tabular menu">
        <a class="active item" data-tab="d1">
            Home
        </a>
        <a class="item" data-tab="d2" @onclick="FetchUsers">
            Nuova Chat
        </a>
        <div class="right menu">
            <div class="item">
                <div class="ui transparent icon input">
                    <input type="text" placeholder="Search users...">
                    <i class="search link icon"></i>
                </div>
            </div>
        </div>
    </div>
    <div class="ui bottom attached tab" data-tab="d1">
        <div class="ui padded equal height grid">
            <div class="four wide column">
                <div class="ui red inverted top attached center aligned segment">
                    <p>
                        Chat
                    </p>
                </div>
                <div class="ui bottom attached very long scrolling segment">
                    @foreach (var (c, i) in _foundChats.Select((c, i) => (c, i)))
                    {
                        <div class="ui attached segment" id="@c.Id" @onclick="() => SetCurrentChat(i)">
                            @_foundChatsNames[i]
                        </div>
                    }
                </div>
            </div>
            <div class="twelve wide column">
                @if (!string.IsNullOrEmpty(_currentChat))
                {
                    <div class="ui red inverted top attached segment">
                        <p>
                            @_chats[_currentChat].Item1
                        </p>
                    </div>

                    <div class="ui seamless attached very long scrolling segment" style="height: 93vh;">
                        @foreach (var m in _chats[_currentChat].Item2)
                        {
                            if (m.SenderId == _myId)
                            {
                                <div class="ui red left aligned compact segment">
                                    @Encoding.UTF8.GetString(m.EncryptedText.ToByteArray())
                                </div>
                            }
                            else
                            {
                                <div class="ui compact blue right aligned segment">
                                    @Encoding.UTF8.GetString(m.EncryptedText.ToByteArray())
                                </div>
                            }
                        }
                    </div>
                    <div class="ui seamless bottom attached segment">
                        <EditForm Model="@_messageModel" OnValidSubmit="@SendMessage">
                            <div class="ui fluid action input">
                                <InputText @bind-Value="_messageModel.message" placeholder="Digita messaggio..."/>
                                <button type="submit" class="ui button">
                                    Invia
                                </button>
                            </div>
                        </EditForm>
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="ui bottom attached tab" data-tab="d2">
        <div>
            <div class="ui list">
                @foreach (var u in _foundUsers)
                {
                    <div class="item" @onclick="() => CreateChat(u.Id)">
                        <i class="huge user circle outline icon"></i>
                        <div class="content">
                            <a class="header">@u.Name @u.Surname</a>
                            <div class="description">
                                <p>@u.Username: @u.Biography</p>
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>
}
else
{
    <div class="ui red text large active loader">
        Loading
    </div>
}

@code {
    bool _isError, _showNoUserFound, _isLoaded;
    string _errorTitle, _errorMessage, _myId, _currentChat;
    readonly Dictionary<string, (string, List<GrpcMessage>)> _chats = new();
    List<UserInfo> _foundUsers = new();
    GrpcChat[] _foundChats = Array.Empty<GrpcChat>();
    List<string> _foundChatsNames = new ();
    AsyncServerStreamingCall<ServerUpdate> _streamingCall;

    readonly Message _messageModel = new()
    {
        message = null
    };

    protected override async Task OnInitializedAsync()
    {
        if (!await ClientUtility.IsServerOn())
        {
            NavigationManager.NavigateTo("/Error");
            return;
        }

        if (!await ClientUtility.IsLoggedIn())
        {
            NavigationManager.NavigateTo("/Login");
            return;
        }

        _streamingCall = ConversationServices.GetUpdateFromServer(new Empty());
        var meResponse = await UserService.FetchMeAsync(new Empty());
        _myId = meResponse.User.Id;
        await GetChats();
        _isLoaded = true;
    }

    // Function callend on every dynamic update
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JsRuntime.InvokeVoidAsync("closeMessages");
        await JsRuntime.InvokeVoidAsync("tabMenu");
    }

    private async Task FetchUsers()
    {
        var response = await ConversationServices.GetUsersForConversationAsync(new Empty());
        switch (response.Result.Status)
        {
            case Status.Ok:
                if (response.Users.Count > 0)
                {
                    _foundUsers = response.Users.ToList();
                }
                else
                {
                    _showNoUserFound = true;
                }

                break;
            case Status.Error:
                _isError = true;
                _errorTitle = "Errore del backend";
                _errorMessage = response.Result.Error;
                break;
            case Status.MissingParameters:
                _isError = true;
                _errorTitle = "Paramentri mancanti";
                _errorMessage = "la richiesta inviata Ã¨ incompleta";
                break;
            case Status.AttachmentTooBig:
                _isError = true;
                _errorTitle = "Messaggio troppo pesante";
                _errorMessage = "il messaggio inviato supera la dimensione massima consentita";
                break;
            case Status.InvalidParameter:
                _isError = true;
                _errorTitle = "Paramentri invalidi";
                _errorMessage = "la richiesta inviata contine parametri invalidi";
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private async Task CreateChat(string userId)
    {
        var response = await ConversationServices.CreateChatAsync(new StringMessage
        {
            Value = userId
        });

        switch (response.Result.Status)
        {
            case Status.Ok:
                _foundUsers.Remove(_foundUsers.Find(u => u.Id == userId)!);
                break;
            case Status.Error:
                _isError = true;
                _errorTitle = "Impossibile creare la chat";
                _errorMessage = response.Result.Error;
                break;
            case Status.MissingParameters:
                _isError = true;
                _errorTitle = "Impossibile creare la chat";
                _errorMessage = "La richiesta non contiene tutti i parametri richiesti";
                break;
            case Status.AttachmentTooBig:
                _isError = true;
                _errorTitle = "Impossibile creare la chat";
                _errorMessage = "La richiesta era troppo pesante";
                break;
            case Status.InvalidParameter:
                _isError = true;
                _errorTitle = "Impossibile creare la chat";
                _errorMessage = "La richiesta contiene dei paramentri non validi";
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private async Task GetChats()
    {
        var response = await ConversationServices.GetAllUserOwnChatsAsync(new Empty());
        switch (response.Result.Status)
        {
            case Status.Ok:
                _foundChats = response.Chats.ToArray();
                ReadStream();
                break;
            case Status.Error:
                break;
            case Status.MissingParameters:
                break;
            case Status.AttachmentTooBig:
                break;
            case Status.InvalidParameter:
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private async void ReadStream()
    {
        try
        {
            while (await _streamingCall.ResponseStream.MoveNext(default))
            {
                switch (_streamingCall.ResponseStream.Current.OperationCase)
                {
                    case ServerUpdate.OperationOneofCase.Chat:
                        break;
                    case ServerUpdate.OperationOneofCase.Group:
                        break;
                    case ServerUpdate.OperationOneofCase.ReceivedMessage:
                        // da fare una funzione per case
                        if (_streamingCall.ResponseStream.Current.ReceivedMessage.Collection.HasChat)
                        {
                            var chatToUpdate = _streamingCall.ResponseStream.Current.ReceivedMessage.Collection.Chat;
                            var messageReceived = _streamingCall.ResponseStream.Current.ReceivedMessage.Message;
                            if (_chats.ContainsKey(chatToUpdate))
                            {
                                _chats[chatToUpdate].Item2.Add(messageReceived);
                            }
                            else
                            {
                                var response = await ConversationServices.GetChatFromIdAsync(new StringMessage
                                {
                                    Value = chatToUpdate
                                }).ResponseAsync;
                                var chat = response.Chat;
                                var id = chat.Members[0] == _myId ? chat.Members[1] : chat.Members[0];
                                var nameResponse = await UserService.FetchUserAsync(new GrpcUserFetch
                                {
                                    Id = id
                                }).ResponseAsync;
                                var name = nameResponse.User.Username;
                                _chats.Add(chat.Id, (name, chat.Messages.Reverse().ToList()));
                            }
                            StateHasChanged();
                        }
                        else
                        {
                            var groupToUpdate = _streamingCall.ResponseStream.Current.ReceivedMessage.Collection.Group;
                            var messageReceived = _streamingCall.ResponseStream.Current.ReceivedMessage.Message;
                            // var updatedGroup = Array.Find(_foundChats, chat => chat.Id == groupToUpdate);
                            // updatedGroup.Messages.Add(messageReceived);
                        }

                        break;
                    case ServerUpdate.OperationOneofCase.DeletedMessages:
                        break;
                    case ServerUpdate.OperationOneofCase.None:
                        break;
                }
            }
        }
        catch (Exception)
        {
            //Ignored
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(_messageModel.message))
        {
            try
            {
                await ConversationServices.SendUpdateToServerAsync(new ClientUpdate
                {
                    SentMessage = new MessageOfCollection
                    {
                        Collection = new Collection
                        {
                            Chat = _currentChat
                        },
                        Message = new GrpcMessage
                        {
                            EncryptedText = ByteString.CopyFromUtf8(_messageModel.message),
                            Iv = ByteString.Empty
                        }
                    }
                });
            }
            catch (Exception e)
            {
                //unused
            }

            _chats[_currentChat].Item2.Add(new GrpcMessage
            {
                EncryptedText = ByteString.CopyFromUtf8(_messageModel.message),
                Iv = ByteString.Empty,
                SenderId = _myId
            });
        }

        _messageModel.message = null;
    }

    private async Task SetCurrentChat(int chatIndex)
    {
        var chatId = _foundChats[chatIndex].Id;
        if (!_chats.ContainsKey(chatId))
        {
            var response = await ConversationServices.GetChatFromIdAsync(new StringMessage
            {
                Value = chatId
            }).ResponseAsync;
            var chat = response.Chat;
            var id = chat.Members[0] == _myId ? chat.Members[1] : chat.Members[0];
            var nameResponse = await UserService.FetchUserAsync(new GrpcUserFetch
            {
                Id = id
            }).ResponseAsync;
            var name = nameResponse.User.Username;
            _chats.Add(chat.Id, (name, chat.Messages.Reverse().ToList()));
        }

        _currentChat = chatId;
        /*_ch
        _currentChat.Messages.Add(new GrpcMessage
        {
            EncryptedText = ByteString.CopyFromUtf8("test sender"),
            SenderId = _currentChat.Members[0]
        });
        _currentChat.Messages.Add(new GrpcMessage
        {
            EncryptedText = ByteString.CopyFromUtf8("test receiver"),
            SenderId = _currentChat.Members[1]
        });
        */
    }

}